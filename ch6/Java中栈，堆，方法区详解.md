# Java JVM 中栈，堆，方法区详解

方法区：类信息、类变量（静态变量和常量）、方法 

堆：对象、成员变量 

栈：局部变量 

1）当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！ 

2）当程序中new一个对象时，这个对象存在堆中，对象的变量存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！ 

3）当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！

类变量：属于类的属性信息，与类的实例无关，多个实例共用同一个类变量，存在与方法区中。类变量用static修饰，包括静态变量和常量。静态变量有默认初始值，常量必须声明同时初始化。

成员变量：属于实例的变量，只与实例有关，写在类下面，方法外，非static修饰。成员变量会随着成员的创建而生存，随着成员的回收而销毁。

局部变量：声明在方法中，没有默认初始值，随着方法的调用而创建，存储于栈中，随着方法调用的结束而销毁。

参考：<https://blog.csdn.net/guohan_solft/article/details/73530244>



---



成员变量在堆内存里，局部变量在栈内存里。（基础类型）

我有疑惑：

既然成员变量存在于对象中，对象存在于堆中，所以成员变量存在于堆中。那么按照这样的推理，局部变量存在于方法中，而方法存在于对象中，对象存在于堆中，那是不是可以说局部变量存在于堆中？

解决思想

当对象new出来，实体存在于堆，对象的成员变量已经在堆上分配空间，但对象里面的方法是没有出现的，只出现方法的声明，方法里面的局部变量并没有创建。等到对象调用此方法时，为了加快运行的速度，方法中的局部变量才会在栈中创建，所以，方法中的局部变量是在栈内的。

当然需要注意的是类变量（静态变量）存在于方法区！！引用类型的局部变量声明在栈，存储在堆



内存：栈 1.存放局部变量 2.不可以被多个线程共享 3.空间连续，速度快

堆 1.存放对象 2.可以被多个线程共享 3.空间不连续，速度慢，但是灵活 

方法区 1.存放类的信息：代码、静态变量、字符串常量等等 2.可以被多个线程共享 3.空间不连续，速度慢，但是灵活

总的来说：我们先来记住两条黄金法则：

1.引用类型总是被分配到“堆”上。不论是成员变量还是局部

2.基础类型总是分配到它声明的地方：成员变量在堆内存里，局部变量在栈内存里。

参考：<https://blog.csdn.net/Noreaday/article/details/79711004>



---



![](https://img-1256179949.cos.ap-shanghai.myqcloud.com/20190731112837.png)

JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)

- 栈区: 

1. **每个线程包含一个栈区**，栈中只保存方法中（不包括对象的成员变量）的**基础数据类型和自定义对象的引用(不是对象)**，对象都存放在堆区中
2. 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3. 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。

- 堆区: 

1. 存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。
2. **jvm只有一个堆区(heap)被所有线程共享**，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的**对象实例和数组**都在堆中分配。

- 方法区: 

1. 又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

来源：https://www.zhihu.com/question/29833675/answer/207261960

